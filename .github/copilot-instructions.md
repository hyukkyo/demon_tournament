# 웹 기반 1v1 턴제 카드 게임 개발 계획서

## 1. 게임 개요 (Game Overview)

-   **프로젝트명:** Web-based 1v1 Turn-based Card Game (가칭)
-   **장르:** 1v1 턴제 전략 카드 게임
-   **핵심 플레이:** 각 플레이어는 라운드마다 3장의 카드를 미리 선택한다. 양쪽의 선택이 완료되면, 선택된 카드들이 순서대로 발동되는 전투 시뮬레이션이 자동으로 진행된다. 상대방의 행동을 예측하여 최적의 수를 내는 것이 핵심 전략이다.

---

## 2. 게임 상세 규칙 및 흐름 (Detailed Game Rules & Flow)

### 2.1. 게임 시작 및 매칭
1.  플레이어는 `매칭 시작`을 통해 상대방을 탐색한다.
2.  매칭이 성사되면 두 플레이어는 게임 룸(Game Room)에 입장한다.
3.  **MVP 범위:** 초기 버전에서는 별도의 유저 로그인 없이 익명으로 매칭 진행. 추후 계정 시스템 추가 예정.

### 2.2. 캐릭터 (Character)
-   **기본 능력치:** 모든 캐릭터는 **체력(HP) 100**, **에너지(Energy) 100**을 가지고 시작한다.
-   **보유 카드:**
    -   **공통 카드 (6장):** 상/하/좌/우 이동, 방어, 에너지 회복
    -   **고유 공격 카드 (4장):** 캐릭터마다 고유한 범위, 위력, 에너지 소모량을 가진다.
-   **카드 사용 제약:**
    -   한 턴에 같은 카드를 여러 장 사용할 수 없다.
    -   에너지가 부족하면 해당 카드를 사용할 수 없다 (카드 선택 시점에 검증).

### 2.3. 게임 진행 (라운드 방식)
게임은 '카드 준비 페이즈'와 '전투 페이즈'가 반복되는 라운드 형식으로 진행된다.

#### A. 카드 준비 페이즈 (Preparation Phase)
1.  각 플레이어는 자신의 덱에서 이번 라운드에 사용할 **카드 3장을 순서대로 선택**한다.
2.  선택을 완료하면 `준비 완료` 상태로 전환한다.
3.  두 플레이어 모두 `준비 완료` 상태가 되면 '전투 페이즈'로 넘어간다.

#### B. 전투 페이즈 (Battle Phase)
1.  **전투 필드:**
    -   크기: 가로 4칸, 세로 3칸의 그리드(Grid)
    -   초기 위치: 두 캐릭터는 중앙 행(2행)의 양쪽 끝(1열, 4열)에 배치된다.
2.  **카드 처리 (시뮬레이션):**
    -   양쪽 플레이어가 선택한 카드가 우선순위에 따라 처리된다.
    -   **카드 우선순위:**
        1.  **이동 카드** (최우선)
        2.  **방어 카드**
        3.  **공격 카드 / 에너지 회복 카드**
    -   같은 우선순위의 카드는 동시에 처리된다 (예: 양쪽이 모두 공격 카드를 낸 경우).
    -   첫 번째 카드 처리 완료 후, 두 번째, 세 번째 카드가 순서대로 처리된다.
    -   **승리 조건:** 카드 처리 중 어느 한쪽이라도 캐릭터의 체력이 0 이하가 되면 즉시 게임이 종료되고 승패가 결정된다.
    -   **무승부 조건:** 양쪽 캐릭터가 동시에 체력이 0 이하가 되면 무승부로 처리된다.

#### C. 라운드 종료 (Round End)
-   3장의 카드가 모두 처리된 후에도 승패가 결정되지 않으면, 다시 '카드 준비 페이즈'로 돌아가 다음 라운드를 시작한다.

### 2.4. 카드 상세 설명 (Card Details)

#### 공통 카드
-   **이동 카드 (상/하/좌/우)**: 캐릭터를 지정된 방향으로 1칸 이동 (에너지 소모: 0)
-   **방어 카드**: 이번 턴에 받는 데미지를 15 감소시킴 (에너지 소모: 10)
-   **에너지 회복 카드**: 에너지를 30 회복 (최대 100)

#### 공격 카드
-   **범위**: 자신의 위치를 중심으로 3x3 영역 내의 특정 칸들을 공격
-   **효과**: 각 카드마다 고유한 공격 패턴, 위력, 에너지 소모량을 가짐
-   **예시**:
    -   십자 공격: 상하좌우 1칸 공격, 위력 30, 에너지 20
    -   전방 공격: 앞쪽 3칸 공격, 위력 25, 에너지 15
    -   광역 공격: 3x3 전체 공격, 위력 20, 에너지 40

---

## 3. 기술 구현 방안 (Technical Implementation Plan)

### 3.1. 핵심 구조: 클라이언트-서버 모델 (Core Architecture: Client-Server Model)
실시간 동기화와 데이터의 공정성 보장을 위해 클라이언트-서버 구조를 채택한다.

-   **클라이언트 (Client / Frontend):**
    -   **역할:** 화면 표시(UI/UX), 사용자 입력 처리
    -   **주요 작업:** 게임 화면 렌더링, 카드 선택 등 사용자 입력을 서버로 전송, 서버로부터 받은 게임 결과를 시각적으로 표현(애니메이션 등).

-   **서버 (Server / Backend):**
    -   **역할:** 게임의 심판. 모든 게임 로직 처리 및 상태 관리.
    -   **주요 작업:** 플레이어 매칭, 게임 룸 관리, 양쪽 플레이어의 카드 선택 데이터 수신, **모든 전투 시뮬레이션(이동, 데미지 계산 등) 직접 수행**, 계산된 결과를 양쪽 클라이언트에 실시간 전송.

> **[중요] 서버 중심 로직의 원칙:**
> 모든 게임 규칙의 판정과 계산은 반드시 서버에서만 이루어져야 한다. 이는 클라이언트 측의 위변조를 원천적으로 차단하여 게임의 공정성을 확보하기 위함이다.

### 3.2. 기술 스택 (Tech Stack)

#### 프론트엔드 (Frontend)
-   **언어:** TypeScript
-   **프레임워크:** React 18
-   **빌드 도구:** Vite (빠른 개발 서버 및 HMR)
-   **상태 관리:** Zustand 또는 Context API
-   **실시간 통신:** Socket.IO-Client
-   **UI 스타일링:** Tailwind CSS
-   **애니메이션:** Framer Motion (게임 연출 및 카드 애니메이션)
-   **개발 도구:** ESLint, Prettier

#### 백엔드 (Backend)
-   **언어/환경:** Node.js 20+ with TypeScript
-   **프레임워크:** Express.js (단순하고 빠른 개발)
-   **실시간 통신:** Socket.IO
-   **게임 로직:** 독립된 게임 엔진 모듈 (pure TypeScript, 테스트 가능한 구조)
-   **테스트:** Jest + Supertest
-   **개발 도구:** ts-node-dev (핫 리로드), ESLint, Prettier

#### MVP 단계 (초기)
-   **데이터 저장:** 서버 메모리 기반 (게임 룸, 플레이어 상태)
-   **인증:** 없음 (익명 매칭)

#### 향후 확장 (Phase 2+)
-   **데이터베이스:** PostgreSQL (유저 계정, 전적)
-   **세션 관리:** Redis (게임 상태, 세션 저장)
-   **인증:** JWT 또는 Session 기반
-   **배포:** Docker, PM2 (프로세스 관리)
-   **모니터링:** Winston (로깅)

### 3.3. 네트워크 문제 대응 방안 (Network Error Handling)

#### 연결 끊김 처리
-   **감지**: Socket.IO의 `disconnect` 이벤트로 연결 끊김 감지
-   **재접속 허용**: 30초 이내 재접속 시 게임 상태 복구 가능
-   **타임아웃**: 30초 이상 재접속하지 않으면 자동 패배 처리
-   **게임 상태 유지**: 서버 메모리에 게임 상태를 유지하여 재접속 시 동기화

#### 카드 선택 타임아웃
-   **제한 시간**: 각 준비 페이즈마다 60초 제한
-   **초과 시**: 랜덤 카드 자동 선택 또는 패배 처리 (추후 결정)

#### Heartbeat
-   **주기적 연결 확인**: Socket.IO의 ping/pong으로 연결 상태 모니터링
-   **응답 없음 시**: 일정 시간 후 연결 끊김으로 처리

### 3.4. 서버 확장성 계획 (Scalability Plan)

#### MVP 단계 (초기)
-   **구조**: 단일 Node.js 서버 + 메모리 기반 게임 룸 관리
-   **장점**: 구현 단순, 빠른 프로토타입 개발
-   **한계**: 서버 재시작 시 모든 게임 상실, 동시 접속 ~100명

#### 확장 단계 (향후)
-   **Redis 도입**: 게임 상태를 Redis에 저장하여 서버 재시작에도 게임 유지
-   **다중 서버**: 여러 서버 인스턴스로 부하 분산
-   **로드 밸런서**: Nginx 또는 클라우드 로드 밸런서 사용

### 3.5. 단계별 개발 계획 (Step-by-step Development Plan)

1.  **1단계: 기본 환경 설정 및 화면 구성**
    -   Frontend(React + Vite)와 Backend(Express + TypeScript) 프로젝트 생성
    -   Socket.IO를 이용해 클라이언트-서버 간 기본 통신 확인
    -   Tailwind CSS로 전투 필드, 캐릭터, 카드 등 정적인 UI 레이아웃 구성
    -   Git 저장소 설정 및 ESLint/Prettier 설정

2.  **2단계: 핵심 로직 구현 (서버 중심)**
    -   서버에서 캐릭터, 카드 등 게임 데이터 구조 정의 (TypeScript 인터페이스)
    -   독립된 게임 엔진 모듈 설계 (테스트 가능한 구조)
    -   서버 메모리 상에서 4x3 전투 필드 데이터 관리 로직 구현
    -   카드 우선순위 처리 로직 구현
    -   클라이언트의 카드 선택 정보를 서버로 전송하는 기능 구현
    -   서버에서 양쪽 카드 정보를 받아 **콘솔(텍스트)에 전투 시뮬레이션 결과를 출력**하는 로직 우선 구현
    -   Jest를 이용한 게임 로직 단위 테스트 작성

3.  **3단계: 시뮬레이션 시각화**
    -   서버의 전투 시뮬레이션 결과를 단계별 이벤트로 클라이언트에 전송
    -   클라이언트는 수신한 데이터를 기반으로 애니메이션 구현:
        -   Framer Motion을 이용한 캐릭터 이동
        -   데미지 표시 및 체력 바 업데이트
        -   카드 사용 연출 (효과음, 시각 효과 등)
    -   실시간 게임 상태 동기화

4.  **4단계: 게임 흐름 완성 및 매칭 구현**
    -   라운드 반복 로직 구현
    -   승/패/무승부 판정 및 결과 화면 표시
    -   카드 선택 시 유효성 검증 (에너지, 중복 사용 등)
    -   대기 중인 플레이어를 연결하여 게임 룸을 생성하는 매칭 시스템 구현
    -   재접속 및 타임아웃 처리
    -   기본 에러 핸들링 및 로깅

